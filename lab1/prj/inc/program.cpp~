#include <time.h>


class Benchmark{

Benchmar(){}


Benchmar(char * _pFilePath, int _nItemCount, int _nLoop){
//konstruktror powinien: zaalokować tabelę pTab,  załadować liczby do niej z pliku, zainicjować licznik elementów nItemCount i nLoop
}



~Benchmar(){
//desktruktor powinien zdeallokować tablicę pTab

}


public:
        //metoda zwrócająca czas wykonania algorytmu zdefiniowanego w pochodnej klasie w metodzie runAlgorythm()
        double testAlgorythm(){
                int t1, t2;
                t1=clock();
                executeAlgorythm();
                return clock() - t1;
        }

private:
        virtual void executeAlgorythm()=0;  //metoda czysto wirtualna , wymagać bedzie przeciążenia w klasach pochodnych

private:
        int nItemCount; //liczba elementów w tablicy
        double * pTab;
        int nLoop; //liczba powtórzeń algorytmu
};

//klasa pochodna
class Potegowanie: public Benchmark{


        Potegowanie(char * _pFilePath, int _nItemCount, int _nLoop){

        Benchmark (_pFilePath,  _nItemCount, _nLoop);
        }


public:
        virtual int executeAlgorythm(){
//wykonań potęgowanie na wszystkich elementach tablicy pTab i zapisując wynik w tabeli na tym samym miejscu, operację wykonań _nLoop razy

                int nLoop=0;                
                int nCounter;
                while (nLoop < _nLoop){
                 nCounter=0;
                 while (nCounter < nItemCount){
                        pTab[nCounter] = pTab[nCounter]^2;  //chyba tak się podnosi do potęgi 2 :)
                        nCounter++;
                 }
                 nLoop++;
                }
        }

};



int main() //jakoś trzeba przekazać parametry do main (nawa pliku, ilość powtórzeń wykonania pętli
{

 Potegowanie * pPotegowanie = new Potegowanie(strPlik, nElementow, nRazy);
 int czas = pPotegowanie->testAlgorythm();
  //wyświetl czas......
 delete pPotegowanie;
}
