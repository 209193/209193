\documentclass[a4paper,10pt]{scrartcl}

\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{pdflscape}

\title{Laboratorium 9}
\author{Filip Malinowski}
\date{\today}

\pdfinfo{%
  /Title    (Laboratorium 9)
  /Author   (Filip Malinowski)
}

\begin{document}

\title{Sprawozdanie z laboratorium 9}
\author{Filip Malinowski}
\date{\today}

\maketitle

W programie został napisany graf z użyciem
macierzy sąsiedztwa. Zaimplementowane zostały
przy tym odpowiednie funkcje tworzące krawędzie
pomiędzy wierzchołkami. Graf tworzony jest na
ustaloną ilość wierzchołków.

Złożoność obliczeniowa tego typu implementacji
grafu jest następująca:
\begin{itemize}
  \item dodanie nowej krawędzi w czasie stałym
  \item sprawdzenie czy dana krawędź istnieje w czasie stałym
  \item usunięcie krawędzi w czasie stałym
\end{itemize}

Ma to jednak jeden minus, a mianowicie duże wymagania
pamięciowe m.in. z powodu macierzy sąsiedzctwa.

Zostały zaimplementowane przeszukiwania
w głąb i wszerz. Oba zostały sprawdzone pod kątem
poprawności działania. Testy szybkości działania
tych przeszukiwań nie zostały przeprowadzone
z racji trudności zautomatyzowania w dodawaniu
dużej ilości wierzchołków oraz krawędzi.

Oba przeszukiwania mają tę samą złożoność
obliczeniową przeszukiwania
\begin{math}
O(V + E),
\end{math}
gdzie V to ilość wierzchołków, a E to ilość
krawędzi.

W mojej implementacji
przeszukiwanie w głąb i wszerz wymaga istnienia
tablicy stanów w celu zapamiętywania informacji
o odwiedzonych komórkach.
Przeszukiwanie wszerz dodadkowo wymaga istnienia
kolejki do przechowywania identyfikatorów
wierzchołków z kolejnych poziomów
co powoduje większą pamięciożerność
od przeszukiwania w głąb.


\end{document}